/* tslint:disable */
/* eslint-disable */
/**
 * meeting room booking system
 * api document
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Booking
 */
export interface Booking {
  /**
   *
   * @type {number}
   * @memberof Booking
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  endTime: string;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  status: BookingStatusEnum;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  note?: string;
  /**
   *
   * @type {User}
   * @memberof Booking
   */
  user: User;
  /**
   *
   * @type {MeetingRoom}
   * @memberof Booking
   */
  room: MeetingRoom;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  createTime: string;
  /**
   *
   * @type {string}
   * @memberof Booking
   */
  updateTime: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BookingStatusEnum {
  Progressing = 'progressing',
  Approved = 'approved',
  Rejected = 'rejected',
  Released = 'released',
}

/**
 *
 * @export
 * @interface BookingListVo
 */
export interface BookingListVo {
  /**
   *
   * @type {Array<Booking>}
   * @memberof BookingListVo
   */
  bookings: Array<Booking>;
  /**
   *
   * @type {number}
   * @memberof BookingListVo
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface BookingListVoUnifiedRes
 */
export interface BookingListVoUnifiedRes {
  /**
   *
   * @type {BookingListVo}
   * @memberof BookingListVoUnifiedRes
   */
  data?: BookingListVo;
  /**
   *
   * @type {number}
   * @memberof BookingListVoUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof BookingListVoUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface CreateBookingDto
 */
export interface CreateBookingDto {
  /**
   *
   * @type {number}
   * @memberof CreateBookingDto
   */
  meetingRoomId: number;
  /**
   *
   * @type {string}
   * @memberof CreateBookingDto
   */
  startTime: string;
  /**
   *
   * @type {string}
   * @memberof CreateBookingDto
   */
  endTime: string;
  /**
   *
   * @type {string}
   * @memberof CreateBookingDto
   */
  note?: string;
}
/**
 *
 * @export
 * @interface CreateMeetingRoomDto
 */
export interface CreateMeetingRoomDto {
  /**
   *
   * @type {string}
   * @memberof CreateMeetingRoomDto
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof CreateMeetingRoomDto
   */
  capacity: number;
  /**
   *
   * @type {string}
   * @memberof CreateMeetingRoomDto
   */
  location: string;
  /**
   *
   * @type {string}
   * @memberof CreateMeetingRoomDto
   */
  equipment: string;
  /**
   *
   * @type {string}
   * @memberof CreateMeetingRoomDto
   */
  description: string;
}
/**
 *
 * @export
 * @interface ErrorReportDto
 */
export interface ErrorReportDto {
  /**
   *
   * @type {string}
   * @memberof ErrorReportDto
   */
  error: string;
  /**
   *
   * @type {string}
   * @memberof ErrorReportDto
   */
  error_info: string;
}
/**
 *
 * @export
 * @interface LoginUserDto
 */
export interface LoginUserDto {
  /**
   *
   * @type {string}
   * @memberof LoginUserDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof LoginUserDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface LoginUserVo
 */
export interface LoginUserVo {
  /**
   *
   * @type {UserInfo}
   * @memberof LoginUserVo
   */
  userInfo: UserInfo;
  /**
   *
   * @type {string}
   * @memberof LoginUserVo
   */
  accessToken: string;
  /**
   *
   * @type {string}
   * @memberof LoginUserVo
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface LoginUserVoUnifiedRes
 */
export interface LoginUserVoUnifiedRes {
  /**
   *
   * @type {LoginUserVo}
   * @memberof LoginUserVoUnifiedRes
   */
  data?: LoginUserVo;
  /**
   *
   * @type {number}
   * @memberof LoginUserVoUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof LoginUserVoUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface MeetingRoom
 */
export interface MeetingRoom {
  /**
   *
   * @type {number}
   * @memberof MeetingRoom
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof MeetingRoom
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof MeetingRoom
   */
  capacity: number;
  /**
   *
   * @type {string}
   * @memberof MeetingRoom
   */
  location: string;
  /**
   *
   * @type {string}
   * @memberof MeetingRoom
   */
  equipment: string;
  /**
   *
   * @type {string}
   * @memberof MeetingRoom
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof MeetingRoom
   */
  isBooked: boolean;
  /**
   *
   * @type {string}
   * @memberof MeetingRoom
   */
  createTime: string;
  /**
   *
   * @type {string}
   * @memberof MeetingRoom
   */
  updateTime: string;
}
/**
 *
 * @export
 * @interface MeetingRoomListVo
 */
export interface MeetingRoomListVo {
  /**
   *
   * @type {Array<MeetingRoom>}
   * @memberof MeetingRoomListVo
   */
  meetingRooms: Array<MeetingRoom>;
  /**
   *
   * @type {number}
   * @memberof MeetingRoomListVo
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface MeetingRoomListVoUnifiedRes
 */
export interface MeetingRoomListVoUnifiedRes {
  /**
   *
   * @type {MeetingRoomListVo}
   * @memberof MeetingRoomListVoUnifiedRes
   */
  data?: MeetingRoomListVo;
  /**
   *
   * @type {number}
   * @memberof MeetingRoomListVoUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof MeetingRoomListVoUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface MeetingRoomUnifiedRes
 */
export interface MeetingRoomUnifiedRes {
  /**
   *
   * @type {MeetingRoom}
   * @memberof MeetingRoomUnifiedRes
   */
  data?: MeetingRoom;
  /**
   *
   * @type {number}
   * @memberof MeetingRoomUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof MeetingRoomUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface NullUnifiedRes
 */
export interface NullUnifiedRes {
  /**
   *
   * @type {string}
   * @memberof NullUnifiedRes
   */
  data?: string;
  /**
   *
   * @type {number}
   * @memberof NullUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof NullUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface PerformanceDto
 */
export interface PerformanceDto {
  /**
   * The name of the metric (in acronym form).
   * @type {string}
   * @memberof PerformanceDto
   */
  name: PerformanceDtoNameEnum;
  /**
   * The current value of the metric.
   * @type {number}
   * @memberof PerformanceDto
   */
  value: number;
  /**
   * The rating as to whether the metric value is within the \"good\", \"needs improvement\", or \"poor\" thresholds of the metric.
   * @type {string}
   * @memberof PerformanceDto
   */
  rating: PerformanceDtoRatingEnum;
  /**
   * The delta between the current value and the last-reported value. On the first report, `delta` and `value` will always be the same.
   * @type {number}
   * @memberof PerformanceDto
   */
  delta: number;
  /**
   * A unique ID representing this particular metric instance. This ID can be used by an analytics tool to dedupe multiple values sent for the same metric instance, or to group multiple deltas together and calculate a total. It can also be used to differentiate multiple different metric instances sent from the same page, which can happen if the page is restored from the back/forward cache (in that case new metrics object get created).
   * @type {string}
   * @memberof PerformanceDto
   */
  id: string;
  /**
   * Any performance entries relevant to the metric value calculation. The array may also be empty if the metric value was not based on any entries (e.g. a CLS value of 0 given no layout shifts).
   * @type {Array<PerformanceEntry>}
   * @memberof PerformanceDto
   */
  entries: Array<PerformanceEntry>;
  /**
   * The type of navigation.  This will be the value returned by the Navigation Timing API (or `undefined` if the browser doesn\'t support that API), with the following exceptions: - \'back-forward-cache\': for pages that are restored from the bfcache. - \'prerender\': for pages that were prerendered. - \'restore\': for pages that were discarded by the browser and then restored by the user.
   * @type {string}
   * @memberof PerformanceDto
   */
  navigationType: PerformanceDtoNavigationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PerformanceDtoNameEnum {
  Cls = 'CLS',
  Fcp = 'FCP',
  Fid = 'FID',
  Inp = 'INP',
  Lcp = 'LCP',
  Ttfb = 'TTFB',
}
/**
 * @export
 * @enum {string}
 */
export enum PerformanceDtoRatingEnum {
  Good = 'good',
  NeedsImprovement = 'needs-improvement',
  Poor = 'poor',
}
/**
 * @export
 * @enum {string}
 */
export enum PerformanceDtoNavigationTypeEnum {
  Navigate = 'navigate',
  Reload = 'reload',
  BackForward = 'back-forward',
  BackForwardCache = 'back-forward-cache',
  Prerender = 'prerender',
  Restore = 'restore',
}

/**
 *
 * @export
 * @interface PerformanceEntry
 */
export interface PerformanceEntry {
  /**
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry/duration)
   * @type {number}
   * @memberof PerformanceEntry
   */
  duration: number;
  /**
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry/entryType)
   * @type {string}
   * @memberof PerformanceEntry
   */
  entryType: string;
  /**
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry/name)
   * @type {string}
   * @memberof PerformanceEntry
   */
  name: string;
  /**
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry/startTime)
   * @type {number}
   * @memberof PerformanceEntry
   */
  startTime: number;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {number}
   * @memberof Permission
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Permission
   */
  description: string;
}
/**
 *
 * @export
 * @interface RefreshTokenVo
 */
export interface RefreshTokenVo {
  /**
   *
   * @type {string}
   * @memberof RefreshTokenVo
   */
  accessToken: string;
  /**
   *
   * @type {string}
   * @memberof RefreshTokenVo
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface RefreshTokenVoUnifiedRes
 */
export interface RefreshTokenVoUnifiedRes {
  /**
   *
   * @type {RefreshTokenVo}
   * @memberof RefreshTokenVoUnifiedRes
   */
  data?: RefreshTokenVo;
  /**
   *
   * @type {number}
   * @memberof RefreshTokenVoUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof RefreshTokenVoUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface RegisterUserDto
 */
export interface RegisterUserDto {
  /**
   *
   * @type {string}
   * @memberof RegisterUserDto
   */
  captcha: string;
  /**
   *
   * @type {string}
   * @memberof RegisterUserDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof RegisterUserDto
   */
  nickName: string;
  /**
   *
   * @type {string}
   * @memberof RegisterUserDto
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof RegisterUserDto
   */
  email: string;
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {number}
   * @memberof Role
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  name: string;
  /**
   *
   * @type {Array<Permission>}
   * @memberof Role
   */
  permissions: Array<Permission>;
}
/**
 *
 * @export
 * @interface UpdateMeetingRoomDto
 */
export interface UpdateMeetingRoomDto {
  /**
   *
   * @type {string}
   * @memberof UpdateMeetingRoomDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateMeetingRoomDto
   */
  capacity?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateMeetingRoomDto
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMeetingRoomDto
   */
  equipment?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMeetingRoomDto
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateMeetingRoomDto
   */
  id: number;
}
/**
 *
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
  /**
   *
   * @type {string}
   * @memberof UpdateUserDto
   */
  nickName: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserDto
   */
  captcha: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserDto
   */
  headPic?: string;
}
/**
 *
 * @export
 * @interface UpdateUserPasswordDto
 */
export interface UpdateUserPasswordDto {
  /**
   *
   * @type {string}
   * @memberof UpdateUserPasswordDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserPasswordDto
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserPasswordDto
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserPasswordDto
   */
  captcha: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nickName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  headPic?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phoneNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  isFrozen: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  isAdmin: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createTime: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updateTime: string;
  /**
   *
   * @type {Array<Role>}
   * @memberof User
   */
  roles: Array<Role>;
}
/**
 *
 * @export
 * @interface UserDetailVo
 */
export interface UserDetailVo {
  /**
   *
   * @type {number}
   * @memberof UserDetailVo
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserDetailVo
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UserDetailVo
   */
  nickName: string;
  /**
   *
   * @type {string}
   * @memberof UserDetailVo
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserDetailVo
   */
  headPic?: string;
  /**
   *
   * @type {string}
   * @memberof UserDetailVo
   */
  phoneNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserDetailVo
   */
  isFrozen: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserDetailVo
   */
  isAdmin: boolean;
  /**
   *
   * @type {string}
   * @memberof UserDetailVo
   */
  createTime: string;
}
/**
 *
 * @export
 * @interface UserDetailVoUnifiedRes
 */
export interface UserDetailVoUnifiedRes {
  /**
   *
   * @type {UserDetailVo}
   * @memberof UserDetailVoUnifiedRes
   */
  data?: UserDetailVo;
  /**
   *
   * @type {number}
   * @memberof UserDetailVoUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof UserDetailVoUnifiedRes
   */
  message?: string;
}
/**
 *
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  createTime: number;
  /**
   *
   * @type {Array<string>}
   * @memberof UserInfo
   */
  roles: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserInfo
   */
  permissions: Array<string>;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  nickName: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  headPic?: string;
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  phoneNumber?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  isFrozen: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserInfo
   */
  isAdmin: boolean;
}
/**
 *
 * @export
 * @interface UserListVo
 */
export interface UserListVo {
  /**
   *
   * @type {Array<UserDetailVo>}
   * @memberof UserListVo
   */
  users: Array<UserDetailVo>;
  /**
   *
   * @type {number}
   * @memberof UserListVo
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface UserListVoUnifiedRes
 */
export interface UserListVoUnifiedRes {
  /**
   *
   * @type {UserListVo}
   * @memberof UserListVoUnifiedRes
   */
  data?: UserListVo;
  /**
   *
   * @type {number}
   * @memberof UserListVoUnifiedRes
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof UserListVoUnifiedRes
   */
  message?: string;
}

/**
 * BookingApi - axios parameter creator
 * @export
 */
export const BookingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CreateBookingDto} createBookingDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerAdd: async (createBookingDto: CreateBookingDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'createBookingDto' is not null or undefined
      assertParamExists('bookingControllerAdd', 'createBookingDto', createBookingDto);
      const localVarPath = `/api/v1/booking/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createBookingDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerApply: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('bookingControllerApply', 'id', id);
      const localVarPath = `/api/v1/booking/apply/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [username]
     * @param {string} [meetingRoomName]
     * @param {string} [meetingRoomPosition]
     * @param {number} [bookingTimeRangeStart]
     * @param {number} [bookingTimeRangeEnd]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerList: async (
      pageNo?: number,
      pageSize?: number,
      username?: string,
      meetingRoomName?: string,
      meetingRoomPosition?: string,
      bookingTimeRangeStart?: number,
      bookingTimeRangeEnd?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/booking/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageNo !== undefined) {
        localVarQueryParameter['pageNo'] = pageNo;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (meetingRoomName !== undefined) {
        localVarQueryParameter['meetingRoomName'] = meetingRoomName;
      }

      if (meetingRoomPosition !== undefined) {
        localVarQueryParameter['meetingRoomPosition'] = meetingRoomPosition;
      }

      if (bookingTimeRangeStart !== undefined) {
        localVarQueryParameter['bookingTimeRangeStart'] = bookingTimeRangeStart;
      }

      if (bookingTimeRangeEnd !== undefined) {
        localVarQueryParameter['bookingTimeRangeEnd'] = bookingTimeRangeEnd;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerReject: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('bookingControllerReject', 'id', id);
      const localVarPath = `/api/v1/booking/reject/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerUnbind: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('bookingControllerUnbind', 'id', id);
      const localVarPath = `/api/v1/booking/unbind/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerUrge: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('bookingControllerUrge', 'id', id);
      const localVarPath = `/api/v1/booking/urge/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BookingApi - functional programming interface
 * @export
 */
export const BookingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BookingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateBookingDto} createBookingDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookingControllerAdd(
      createBookingDto: CreateBookingDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerAdd(createBookingDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookingControllerApply(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerApply(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [username]
     * @param {string} [meetingRoomName]
     * @param {string} [meetingRoomPosition]
     * @param {number} [bookingTimeRangeStart]
     * @param {number} [bookingTimeRangeEnd]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookingControllerList(
      pageNo?: number,
      pageSize?: number,
      username?: string,
      meetingRoomName?: string,
      meetingRoomPosition?: string,
      bookingTimeRangeStart?: number,
      bookingTimeRangeEnd?: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookingListVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerList(
        pageNo,
        pageSize,
        username,
        meetingRoomName,
        meetingRoomPosition,
        bookingTimeRangeStart,
        bookingTimeRangeEnd,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookingControllerReject(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerReject(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookingControllerUnbind(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerUnbind(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bookingControllerUrge(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bookingControllerUrge(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * BookingApi - factory interface
 * @export
 */
export const BookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = BookingApiFp(configuration);
  return {
    /**
     *
     * @param {CreateBookingDto} createBookingDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerAdd(createBookingDto: CreateBookingDto, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.bookingControllerAdd(createBookingDto, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerApply(id: number, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.bookingControllerApply(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [username]
     * @param {string} [meetingRoomName]
     * @param {string} [meetingRoomPosition]
     * @param {number} [bookingTimeRangeStart]
     * @param {number} [bookingTimeRangeEnd]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerList(
      pageNo?: number,
      pageSize?: number,
      username?: string,
      meetingRoomName?: string,
      meetingRoomPosition?: string,
      bookingTimeRangeStart?: number,
      bookingTimeRangeEnd?: number,
      options?: any
    ): AxiosPromise<BookingListVoUnifiedRes> {
      return localVarFp
        .bookingControllerList(
          pageNo,
          pageSize,
          username,
          meetingRoomName,
          meetingRoomPosition,
          bookingTimeRangeStart,
          bookingTimeRangeEnd,
          options
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerReject(id: number, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.bookingControllerReject(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerUnbind(id: number, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.bookingControllerUnbind(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bookingControllerUrge(id: number, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.bookingControllerUrge(id, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * BookingApi - object-oriented interface
 * @export
 * @class BookingApi
 * @extends {BaseAPI}
 */
export class BookingApi extends BaseAPI {
  /**
   *
   * @param {CreateBookingDto} createBookingDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookingApi
   */
  public bookingControllerAdd(createBookingDto: CreateBookingDto, options?: any) {
    return BookingApiFp(this.configuration)
      .bookingControllerAdd(createBookingDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookingApi
   */
  public bookingControllerApply(id: number, options?: any) {
    return BookingApiFp(this.configuration)
      .bookingControllerApply(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [pageNo]
   * @param {number} [pageSize]
   * @param {string} [username]
   * @param {string} [meetingRoomName]
   * @param {string} [meetingRoomPosition]
   * @param {number} [bookingTimeRangeStart]
   * @param {number} [bookingTimeRangeEnd]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookingApi
   */
  public bookingControllerList(
    pageNo?: number,
    pageSize?: number,
    username?: string,
    meetingRoomName?: string,
    meetingRoomPosition?: string,
    bookingTimeRangeStart?: number,
    bookingTimeRangeEnd?: number,
    options?: any
  ) {
    return BookingApiFp(this.configuration)
      .bookingControllerList(
        pageNo,
        pageSize,
        username,
        meetingRoomName,
        meetingRoomPosition,
        bookingTimeRangeStart,
        bookingTimeRangeEnd,
        options
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookingApi
   */
  public bookingControllerReject(id: number, options?: any) {
    return BookingApiFp(this.configuration)
      .bookingControllerReject(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookingApi
   */
  public bookingControllerUnbind(id: number, options?: any) {
    return BookingApiFp(this.configuration)
      .bookingControllerUnbind(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BookingApi
   */
  public bookingControllerUrge(id: number, options?: any) {
    return BookingApiFp(this.configuration)
      .bookingControllerUrge(id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FEReportApi - axios parameter creator
 * @export
 */
export const FEReportApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {ErrorReportDto} errorReportDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feReportControllerError: async (errorReportDto: ErrorReportDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'errorReportDto' is not null or undefined
      assertParamExists('feReportControllerError', 'errorReportDto', errorReportDto);
      const localVarPath = `/api/v1/fe-report/error`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(errorReportDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PerformanceDto} performanceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feReportControllerPerformance: async (performanceDto: PerformanceDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'performanceDto' is not null or undefined
      assertParamExists('feReportControllerPerformance', 'performanceDto', performanceDto);
      const localVarPath = `/api/v1/fe-report/performance`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(performanceDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FEReportApi - functional programming interface
 * @export
 */
export const FEReportApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FEReportApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ErrorReportDto} errorReportDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feReportControllerError(
      errorReportDto: ErrorReportDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.feReportControllerError(errorReportDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {PerformanceDto} performanceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feReportControllerPerformance(
      performanceDto: PerformanceDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.feReportControllerPerformance(performanceDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FEReportApi - factory interface
 * @export
 */
export const FEReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FEReportApiFp(configuration);
  return {
    /**
     *
     * @param {ErrorReportDto} errorReportDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feReportControllerError(errorReportDto: ErrorReportDto, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.feReportControllerError(errorReportDto, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {PerformanceDto} performanceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feReportControllerPerformance(performanceDto: PerformanceDto, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp
        .feReportControllerPerformance(performanceDto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * FEReportApi - object-oriented interface
 * @export
 * @class FEReportApi
 * @extends {BaseAPI}
 */
export class FEReportApi extends BaseAPI {
  /**
   *
   * @param {ErrorReportDto} errorReportDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FEReportApi
   */
  public feReportControllerError(errorReportDto: ErrorReportDto, options?: any) {
    return FEReportApiFp(this.configuration)
      .feReportControllerError(errorReportDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PerformanceDto} performanceDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FEReportApi
   */
  public feReportControllerPerformance(performanceDto: PerformanceDto, options?: any) {
    return FEReportApiFp(this.configuration)
      .feReportControllerPerformance(performanceDto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MeetingRoomApi - axios parameter creator
 * @export
 */
export const MeetingRoomApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CreateMeetingRoomDto} createMeetingRoomDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerCreate: async (
      createMeetingRoomDto: CreateMeetingRoomDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createMeetingRoomDto' is not null or undefined
      assertParamExists('meetingRoomControllerCreate', 'createMeetingRoomDto', createMeetingRoomDto);
      const localVarPath = `/api/v1/meeting-room/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createMeetingRoomDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('meetingRoomControllerDelete', 'id', id);
      const localVarPath = `/api/v1/meeting-room/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerFind: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('meetingRoomControllerFind', 'id', id);
      const localVarPath = `/api/v1/meeting-room/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [name]
     * @param {number} [capacity]
     * @param {string} [equipment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerList: async (
      pageNo?: number,
      pageSize?: number,
      name?: string,
      capacity?: number,
      equipment?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/meeting-room/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageNo !== undefined) {
        localVarQueryParameter['pageNo'] = pageNo;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name;
      }

      if (capacity !== undefined) {
        localVarQueryParameter['capacity'] = capacity;
      }

      if (equipment !== undefined) {
        localVarQueryParameter['equipment'] = equipment;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateMeetingRoomDto} updateMeetingRoomDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerUpdate: async (
      updateMeetingRoomDto: UpdateMeetingRoomDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateMeetingRoomDto' is not null or undefined
      assertParamExists('meetingRoomControllerUpdate', 'updateMeetingRoomDto', updateMeetingRoomDto);
      const localVarPath = `/api/v1/meeting-room/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateMeetingRoomDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MeetingRoomApi - functional programming interface
 * @export
 */
export const MeetingRoomApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MeetingRoomApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateMeetingRoomDto} createMeetingRoomDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meetingRoomControllerCreate(
      createMeetingRoomDto: CreateMeetingRoomDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRoomUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meetingRoomControllerCreate(
        createMeetingRoomDto,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meetingRoomControllerDelete(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meetingRoomControllerDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meetingRoomControllerFind(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRoomUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meetingRoomControllerFind(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [name]
     * @param {number} [capacity]
     * @param {string} [equipment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meetingRoomControllerList(
      pageNo?: number,
      pageSize?: number,
      name?: string,
      capacity?: number,
      equipment?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRoomListVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meetingRoomControllerList(
        pageNo,
        pageSize,
        name,
        capacity,
        equipment,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UpdateMeetingRoomDto} updateMeetingRoomDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meetingRoomControllerUpdate(
      updateMeetingRoomDto: UpdateMeetingRoomDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meetingRoomControllerUpdate(
        updateMeetingRoomDto,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * MeetingRoomApi - factory interface
 * @export
 */
export const MeetingRoomApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MeetingRoomApiFp(configuration);
  return {
    /**
     *
     * @param {CreateMeetingRoomDto} createMeetingRoomDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerCreate(
      createMeetingRoomDto: CreateMeetingRoomDto,
      options?: any
    ): AxiosPromise<MeetingRoomUnifiedRes> {
      return localVarFp
        .meetingRoomControllerCreate(createMeetingRoomDto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerDelete(id: number, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.meetingRoomControllerDelete(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerFind(id: number, options?: any): AxiosPromise<MeetingRoomUnifiedRes> {
      return localVarFp.meetingRoomControllerFind(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [name]
     * @param {number} [capacity]
     * @param {string} [equipment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerList(
      pageNo?: number,
      pageSize?: number,
      name?: string,
      capacity?: number,
      equipment?: string,
      options?: any
    ): AxiosPromise<MeetingRoomListVoUnifiedRes> {
      return localVarFp
        .meetingRoomControllerList(pageNo, pageSize, name, capacity, equipment, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateMeetingRoomDto} updateMeetingRoomDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meetingRoomControllerUpdate(
      updateMeetingRoomDto: UpdateMeetingRoomDto,
      options?: any
    ): AxiosPromise<NullUnifiedRes> {
      return localVarFp
        .meetingRoomControllerUpdate(updateMeetingRoomDto, options)
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * MeetingRoomApi - object-oriented interface
 * @export
 * @class MeetingRoomApi
 * @extends {BaseAPI}
 */
export class MeetingRoomApi extends BaseAPI {
  /**
   *
   * @param {CreateMeetingRoomDto} createMeetingRoomDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingRoomApi
   */
  public meetingRoomControllerCreate(createMeetingRoomDto: CreateMeetingRoomDto, options?: any) {
    return MeetingRoomApiFp(this.configuration)
      .meetingRoomControllerCreate(createMeetingRoomDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingRoomApi
   */
  public meetingRoomControllerDelete(id: number, options?: any) {
    return MeetingRoomApiFp(this.configuration)
      .meetingRoomControllerDelete(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingRoomApi
   */
  public meetingRoomControllerFind(id: number, options?: any) {
    return MeetingRoomApiFp(this.configuration)
      .meetingRoomControllerFind(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [pageNo]
   * @param {number} [pageSize]
   * @param {string} [name]
   * @param {number} [capacity]
   * @param {string} [equipment]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingRoomApi
   */
  public meetingRoomControllerList(
    pageNo?: number,
    pageSize?: number,
    name?: string,
    capacity?: number,
    equipment?: string,
    options?: any
  ) {
    return MeetingRoomApiFp(this.configuration)
      .meetingRoomControllerList(pageNo, pageSize, name, capacity, equipment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateMeetingRoomDto} updateMeetingRoomDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingRoomApi
   */
  public meetingRoomControllerUpdate(updateMeetingRoomDto: UpdateMeetingRoomDto, options?: any) {
    return MeetingRoomApiFp(this.configuration)
      .meetingRoomControllerUpdate(updateMeetingRoomDto, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SSEApi - axios parameter creator
 * @export
 */
export const SSEApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sseControllerUpdateRecord: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/sse/update_record`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SSEApi - functional programming interface
 * @export
 */
export const SSEApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SSEApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sseControllerUpdateRecord(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sseControllerUpdateRecord(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * SSEApi - factory interface
 * @export
 */
export const SSEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SSEApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sseControllerUpdateRecord(options?: any): AxiosPromise<object> {
      return localVarFp.sseControllerUpdateRecord(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SSEApi - object-oriented interface
 * @export
 * @class SSEApi
 * @extends {BaseAPI}
 */
export class SSEApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SSEApi
   */
  public sseControllerUpdateRecord(options?: any) {
    return SSEApiFp(this.configuration)
      .sseControllerUpdateRecord(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {LoginUserDto} loginUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerAdminLogin: async (loginUserDto: LoginUserDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginUserDto' is not null or undefined
      assertParamExists('userControllerAdminLogin', 'loginUserDto', loginUserDto);
      const localVarPath = `/api/v1/user/admin/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(loginUserDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerAdminRefresh: async (refreshToken: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists('userControllerAdminRefresh', 'refreshToken', refreshToken);
      const localVarPath = `/api/v1/user/admin/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (refreshToken !== undefined) {
        localVarQueryParameter['refreshToken'] = refreshToken;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerCaptcha: async (address: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('userControllerCaptcha', 'address', address);
      const localVarPath = `/api/v1/user/register-captcha`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (address !== undefined) {
        localVarQueryParameter['address'] = address;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerFreeze: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerFreeze', 'id', id);
      const localVarPath = `/api/v1/user/freeze`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerInfo: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/user/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [email]
     * @param {string} [username]
     * @param {string} [nickName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerList: async (
      pageNo?: number,
      pageSize?: number,
      email?: string,
      username?: string,
      nickName?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/user/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageNo !== undefined) {
        localVarQueryParameter['pageNo'] = pageNo;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      if (nickName !== undefined) {
        localVarQueryParameter['nickName'] = nickName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRefresh: async (refreshToken: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists('userControllerRefresh', 'refreshToken', refreshToken);
      const localVarPath = `/api/v1/user/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (refreshToken !== undefined) {
        localVarQueryParameter['refreshToken'] = refreshToken;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RegisterUserDto} registerUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRegister: async (registerUserDto: RegisterUserDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'registerUserDto' is not null or undefined
      assertParamExists('userControllerRegister', 'registerUserDto', registerUserDto);
      const localVarPath = `/api/v1/user/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(registerUserDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdate: async (updateUserDto: UpdateUserDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateUserDto' is not null or undefined
      assertParamExists('userControllerUpdate', 'updateUserDto', updateUserDto);
      const localVarPath = `/api/v1/user/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdateCaptcha: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/user/update/captcha`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateUserPasswordDto} updateUserPasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdatePassword: async (
      updateUserPasswordDto: UpdateUserPasswordDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateUserPasswordDto' is not null or undefined
      assertParamExists('userControllerUpdatePassword', 'updateUserPasswordDto', updateUserPasswordDto);
      const localVarPath = `/api/v1/user/update_password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdatePasswordCaptcha: async (address: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'address' is not null or undefined
      assertParamExists('userControllerUpdatePasswordCaptcha', 'address', address);
      const localVarPath = `/api/v1/user/update_password/captcha`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (address !== undefined) {
        localVarQueryParameter['address'] = address;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateUserPasswordDto} updateUserPasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdatePassword_1: async (
      updateUserPasswordDto: UpdateUserPasswordDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateUserPasswordDto' is not null or undefined
      assertParamExists('userControllerUpdatePassword_1', 'updateUserPasswordDto', updateUserPasswordDto);
      const localVarPath = `/api/v1/user/admin/update_password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdate_2: async (updateUserDto: UpdateUserDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateUserDto' is not null or undefined
      assertParamExists('userControllerUpdate_2', 'updateUserDto', updateUserDto);
      const localVarPath = `/api/v1/user/admin/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUploadFile: async (file?: any, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/user/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {LoginUserDto} loginUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUserLogin: async (loginUserDto: LoginUserDto, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginUserDto' is not null or undefined
      assertParamExists('userControllerUserLogin', 'loginUserDto', loginUserDto);
      const localVarPath = `/api/v1/user/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(loginUserDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {LoginUserDto} loginUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerAdminLogin(
      loginUserDto: LoginUserDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAdminLogin(loginUserDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerAdminRefresh(
      refreshToken: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAdminRefresh(refreshToken, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerCaptcha(
      address: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCaptcha(address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerFreeze(
      id: number,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFreeze(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerInfo(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetailVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [email]
     * @param {string} [username]
     * @param {string} [nickName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerList(
      pageNo?: number,
      pageSize?: number,
      email?: string,
      username?: string,
      nickName?: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerList(
        pageNo,
        pageSize,
        email,
        username,
        nickName,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRefresh(
      refreshToken: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRefresh(refreshToken, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {RegisterUserDto} registerUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRegister(
      registerUserDto: RegisterUserDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRegister(registerUserDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdate(
      updateUserDto: UpdateUserDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(updateUserDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdateCaptcha(
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateCaptcha(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UpdateUserPasswordDto} updateUserPasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdatePassword(
      updateUserPasswordDto: UpdateUserPasswordDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdatePassword(
        updateUserPasswordDto,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdatePasswordCaptcha(
      address: string,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdatePasswordCaptcha(address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UpdateUserPasswordDto} updateUserPasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdatePassword_1(
      updateUserPasswordDto: UpdateUserPasswordDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdatePassword_1(
        updateUserPasswordDto,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdate_2(
      updateUserDto: UpdateUserDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate_2(updateUserDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUploadFile(
      file?: any,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NullUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUploadFile(file, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {LoginUserDto} loginUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUserLogin(
      loginUserDto: LoginUserDto,
      options?: any
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserVoUnifiedRes>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUserLogin(loginUserDto, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @param {LoginUserDto} loginUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerAdminLogin(loginUserDto: LoginUserDto, options?: any): AxiosPromise<LoginUserVoUnifiedRes> {
      return localVarFp.userControllerAdminLogin(loginUserDto, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerAdminRefresh(refreshToken: string, options?: any): AxiosPromise<RefreshTokenVoUnifiedRes> {
      return localVarFp.userControllerAdminRefresh(refreshToken, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerCaptcha(address: string, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerCaptcha(address, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerFreeze(id: number, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerFreeze(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerInfo(options?: any): AxiosPromise<UserDetailVoUnifiedRes> {
      return localVarFp.userControllerInfo(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} [pageNo]
     * @param {number} [pageSize]
     * @param {string} [email]
     * @param {string} [username]
     * @param {string} [nickName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerList(
      pageNo?: number,
      pageSize?: number,
      email?: string,
      username?: string,
      nickName?: string,
      options?: any
    ): AxiosPromise<UserListVoUnifiedRes> {
      return localVarFp
        .userControllerList(pageNo, pageSize, email, username, nickName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRefresh(refreshToken: string, options?: any): AxiosPromise<RefreshTokenVoUnifiedRes> {
      return localVarFp.userControllerRefresh(refreshToken, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {RegisterUserDto} registerUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRegister(registerUserDto: RegisterUserDto, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerRegister(registerUserDto, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdate(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerUpdate(updateUserDto, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdateCaptcha(options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerUpdateCaptcha(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateUserPasswordDto} updateUserPasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdatePassword(
      updateUserPasswordDto: UpdateUserPasswordDto,
      options?: any
    ): AxiosPromise<NullUnifiedRes> {
      return localVarFp
        .userControllerUpdatePassword(updateUserPasswordDto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdatePasswordCaptcha(address: string, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerUpdatePasswordCaptcha(address, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateUserPasswordDto} updateUserPasswordDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdatePassword_1(
      updateUserPasswordDto: UpdateUserPasswordDto,
      options?: any
    ): AxiosPromise<NullUnifiedRes> {
      return localVarFp
        .userControllerUpdatePassword_1(updateUserPasswordDto, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdate_2(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerUpdate_2(updateUserDto, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUploadFile(file?: any, options?: any): AxiosPromise<NullUnifiedRes> {
      return localVarFp.userControllerUploadFile(file, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {LoginUserDto} loginUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUserLogin(loginUserDto: LoginUserDto, options?: any): AxiosPromise<LoginUserVoUnifiedRes> {
      return localVarFp.userControllerUserLogin(loginUserDto, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @param {LoginUserDto} loginUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerAdminLogin(loginUserDto: LoginUserDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerAdminLogin(loginUserDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} refreshToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerAdminRefresh(refreshToken: string, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerAdminRefresh(refreshToken, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerCaptcha(address: string, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerCaptcha(address, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerFreeze(id: number, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerFreeze(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerInfo(options?: any) {
    return UserApiFp(this.configuration)
      .userControllerInfo(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} [pageNo]
   * @param {number} [pageSize]
   * @param {string} [email]
   * @param {string} [username]
   * @param {string} [nickName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerList(
    pageNo?: number,
    pageSize?: number,
    email?: string,
    username?: string,
    nickName?: string,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .userControllerList(pageNo, pageSize, email, username, nickName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} refreshToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerRefresh(refreshToken: string, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerRefresh(refreshToken, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RegisterUserDto} registerUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerRegister(registerUserDto: RegisterUserDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerRegister(registerUserDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateUserDto} updateUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdate(updateUserDto: UpdateUserDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUpdate(updateUserDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdateCaptcha(options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUpdateCaptcha(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateUserPasswordDto} updateUserPasswordDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdatePassword(updateUserPasswordDto: UpdateUserPasswordDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUpdatePassword(updateUserPasswordDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdatePasswordCaptcha(address: string, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUpdatePasswordCaptcha(address, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateUserPasswordDto} updateUserPasswordDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdatePassword_1(updateUserPasswordDto: UpdateUserPasswordDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUpdatePassword_1(updateUserPasswordDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateUserDto} updateUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdate_2(updateUserDto: UpdateUserDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUpdate_2(updateUserDto, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} [file]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUploadFile(file?: any, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUploadFile(file, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LoginUserDto} loginUserDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUserLogin(loginUserDto: LoginUserDto, options?: any) {
    return UserApiFp(this.configuration)
      .userControllerUserLogin(loginUserDto, options)
      .then(request => request(this.axios, this.basePath));
  }
}
